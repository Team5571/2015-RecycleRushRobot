// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc5571.RobotFinal.commands;

import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.CommandGroup;

import org.usfirst.frc5571.RobotFinal.Robot;
import org.usfirst.frc5571.RobotFinal.RobotMap;


/**
 * Bobby Gintz
 * 
 * This is a simple autonomous command group that sequences between a number of planned moves from a given position
 * After determining reasonable values for 90 degree turns and distance traveled in a straight line they can be
 * coded here.  
 * 
 * Note:  there is no compensation for drift so straight line distances may not be straight
 * 
 * Also:  Use caution when testing this command.  Be prepared to hit the SPACE bar on the driver station
 * which will cause an E-STOP
 */




public class  AutonomousCommand extends CommandGroup {
	// Flag to end the command
	Boolean autoDone = false;
	//Boolean autoDriveCommandInProgress = false;

	// Scaling factors to adjust drive sensitivity during autonomous to simulate Joystick deflections. 
	static double AUTO_FAST_DRIVE_MAGNITUDE_SCALE = 0.6;
	static double AUTO_FAST_DRIVE_TWIST_SCALE = 0.5;
	static double AUTO_FINE_DRIVE_MAGNITUDE_SCALE = 0.4;
	static double AUTO_FINE_DRIVE_TWIST_SCALE = 0.3;
	
	static double DRIVE_TO_AUTO	= 1.2;	/* 1.2 seconds to go from start posision to auto zone */
	static Double TIME_TO_ROTATE_90_DEGREES = 0.67;

	public AutonomousCommand() {
		// Use requires() here to declare subsystem dependencies
		// eg. requires(chassis);

		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
		addSequential(new RotateLeft90Command(TIME_TO_ROTATE_90_DEGREES));
		//addSequential(new DriveForwardCommand());
		autoDone = true;
		//(Robot.driveTrain);


	}

	// Called just before this Command runs the first time
	protected void initialize() {
		Robot.driveTrain.initInvert();
//		autoDriveCommandInProgress = false;
	}



	// Called repeatedly when this Command is scheduled to run
	protected void execute() {

		
		// Rotate Right at slow speed for 0.67 seconds
		//autonomousDriveFine(0,0, 1, 0.67 );

		// Drive straight ahead at low speed for 1.5 seconds //
		//autonomousDriveFine(1, 0, 0, 1.5);



		// All done with autonomous
		//autoDone = true;

	}

//	void autonomousDriveFine(double magnitude, double direction, double rotation, double time){
//		if (!autoDriveCommandInProgress){
//			autoDriveCommandInProgress = true;
//			int number_of_20msec_cycles = (int) (time *50);
//			while (number_of_20msec_cycles>0){
//				//Robot.driveTrain.mecanumDriveAutoFine(magnitude, direction, rotation, numberOfCycles);
//				RobotMap.driveTrainRobotDrive41.mecanumDrive_Polar(magnitude*AUTO_FINE_DRIVE_MAGNITUDE_SCALE, direction*AUTO_FINE_DRIVE_MAGNITUDE_SCALE -1.0, rotation *AUTO_FINE_DRIVE_TWIST_SCALE);
//				--number_of_20msec_cycles;
//			}
//		}
//		else{
//			
//		}
//	}


	// Make this return true when this Command no longer needs to run execute()
	protected boolean isFinished() {
		return autoDone;
	}

	// Called once after isFinished returns true
	protected void end() {
	}

	// Called when another command which requires one or more of the same
	// subsystems is scheduled to run
	protected void interrupted() {
	}
}
